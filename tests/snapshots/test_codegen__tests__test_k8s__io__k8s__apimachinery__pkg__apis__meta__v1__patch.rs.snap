---
source: tests/test_codegen.rs
expression: data
---

/// Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct Patch {}

impl Patch {
    /// partially update the specified ConfigMap
    #[inline]
    pub fn patch_core_v1_namespaced_config_map() -> PatchPatchBuilder<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Endpoints
    #[inline]
    pub fn patch_core_v1_namespaced_endpoints() -> PatchPatchBuilder1<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder1 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Event
    #[inline]
    pub fn patch_core_v1_namespaced_event() -> PatchPatchBuilder2<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder2 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified LimitRange
    #[inline]
    pub fn patch_core_v1_namespaced_limit_range() -> PatchPatchBuilder3<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder3 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified PersistentVolumeClaim
    #[inline]
    pub fn patch_core_v1_namespaced_persistent_volume_claim() -> PatchPatchBuilder4<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder4 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified PersistentVolumeClaim
    #[inline]
    pub fn patch_core_v1_namespaced_persistent_volume_claim_status() -> PatchPatchBuilder5<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder5 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Pod
    #[inline]
    pub fn patch_core_v1_namespaced_pod() -> PatchPatchBuilder6<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder6 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Pod
    #[inline]
    pub fn patch_core_v1_namespaced_pod_status() -> PatchPatchBuilder7<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder7 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified PodTemplate
    #[inline]
    pub fn patch_core_v1_namespaced_pod_template() -> PatchPatchBuilder8<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder8 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ReplicationController
    #[inline]
    pub fn patch_core_v1_namespaced_replication_controller() -> PatchPatchBuilder9<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder9 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified ReplicationController
    #[inline]
    pub fn patch_core_v1_namespaced_replication_controller_scale() -> PatchPatchBuilder10<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder10 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified ReplicationController
    #[inline]
    pub fn patch_core_v1_namespaced_replication_controller_status() -> PatchPatchBuilder11<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder11 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ResourceQuota
    #[inline]
    pub fn patch_core_v1_namespaced_resource_quota() -> PatchPatchBuilder12<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder12 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified ResourceQuota
    #[inline]
    pub fn patch_core_v1_namespaced_resource_quota_status() -> PatchPatchBuilder13<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder13 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Secret
    #[inline]
    pub fn patch_core_v1_namespaced_secret() -> PatchPatchBuilder14<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder14 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ServiceAccount
    #[inline]
    pub fn patch_core_v1_namespaced_service_account() -> PatchPatchBuilder15<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder15 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Service
    #[inline]
    pub fn patch_core_v1_namespaced_service() -> PatchPatchBuilder16<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder16 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Service
    #[inline]
    pub fn patch_core_v1_namespaced_service_status() -> PatchPatchBuilder17<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder17 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Namespace
    #[inline]
    pub fn patch_core_v1_namespace() -> PatchPatchBuilder18<crate::codegen::generics::MissingName> {
        PatchPatchBuilder18 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Namespace
    #[inline]
    pub fn patch_core_v1_namespace_status() -> PatchPatchBuilder19<crate::codegen::generics::MissingName> {
        PatchPatchBuilder19 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified Node
    #[inline]
    pub fn patch_core_v1_node() -> PatchPatchBuilder20<crate::codegen::generics::MissingName> {
        PatchPatchBuilder20 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Node
    #[inline]
    pub fn patch_core_v1_node_status() -> PatchPatchBuilder21<crate::codegen::generics::MissingName> {
        PatchPatchBuilder21 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified PersistentVolume
    #[inline]
    pub fn patch_core_v1_persistent_volume() -> PatchPatchBuilder22<crate::codegen::generics::MissingName> {
        PatchPatchBuilder22 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified PersistentVolume
    #[inline]
    pub fn patch_core_v1_persistent_volume_status() -> PatchPatchBuilder23<crate::codegen::generics::MissingName> {
        PatchPatchBuilder23 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified MutatingWebhookConfiguration
    #[inline]
    pub fn patch_admissionregistration_v1beta1_mutating_webhook_configuration() -> PatchPatchBuilder24<crate::codegen::generics::MissingName> {
        PatchPatchBuilder24 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified ValidatingWebhookConfiguration
    #[inline]
    pub fn patch_admissionregistration_v1beta1_validating_webhook_configuration() -> PatchPatchBuilder25<crate::codegen::generics::MissingName> {
        PatchPatchBuilder25 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified CustomResourceDefinition
    #[inline]
    pub fn patch_apiextensions_v1beta1_custom_resource_definition() -> PatchPatchBuilder26<crate::codegen::generics::MissingName> {
        PatchPatchBuilder26 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified CustomResourceDefinition
    #[inline]
    pub fn patch_apiextensions_v1beta1_custom_resource_definition_status() -> PatchPatchBuilder27<crate::codegen::generics::MissingName> {
        PatchPatchBuilder27 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified APIService
    #[inline]
    pub fn patch_apiregistration_v1api_service() -> PatchPatchBuilder28<crate::codegen::generics::MissingName> {
        PatchPatchBuilder28 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified APIService
    #[inline]
    pub fn patch_apiregistration_v1api_service_status() -> PatchPatchBuilder29<crate::codegen::generics::MissingName> {
        PatchPatchBuilder29 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified APIService
    #[inline]
    pub fn patch_apiregistration_v1beta1_api_service() -> PatchPatchBuilder30<crate::codegen::generics::MissingName> {
        PatchPatchBuilder30 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified APIService
    #[inline]
    pub fn patch_apiregistration_v1beta1_api_service_status() -> PatchPatchBuilder31<crate::codegen::generics::MissingName> {
        PatchPatchBuilder31 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified ControllerRevision
    #[inline]
    pub fn patch_apps_v1_namespaced_controller_revision() -> PatchPatchBuilder32<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder32 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified DaemonSet
    #[inline]
    pub fn patch_apps_v1_namespaced_daemon_set() -> PatchPatchBuilder33<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder33 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified DaemonSet
    #[inline]
    pub fn patch_apps_v1_namespaced_daemon_set_status() -> PatchPatchBuilder34<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder34 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Deployment
    #[inline]
    pub fn patch_apps_v1_namespaced_deployment() -> PatchPatchBuilder35<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder35 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified Deployment
    #[inline]
    pub fn patch_apps_v1_namespaced_deployment_scale() -> PatchPatchBuilder36<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder36 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Deployment
    #[inline]
    pub fn patch_apps_v1_namespaced_deployment_status() -> PatchPatchBuilder37<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder37 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ReplicaSet
    #[inline]
    pub fn patch_apps_v1_namespaced_replica_set() -> PatchPatchBuilder38<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder38 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified ReplicaSet
    #[inline]
    pub fn patch_apps_v1_namespaced_replica_set_scale() -> PatchPatchBuilder39<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder39 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified ReplicaSet
    #[inline]
    pub fn patch_apps_v1_namespaced_replica_set_status() -> PatchPatchBuilder40<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder40 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1_namespaced_stateful_set() -> PatchPatchBuilder41<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder41 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1_namespaced_stateful_set_scale() -> PatchPatchBuilder42<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder42 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1_namespaced_stateful_set_status() -> PatchPatchBuilder43<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder43 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ControllerRevision
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_controller_revision() -> PatchPatchBuilder44<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder44 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Deployment
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_deployment() -> PatchPatchBuilder45<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder45 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified Deployment
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_deployment_scale() -> PatchPatchBuilder46<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder46 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Deployment
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_deployment_status() -> PatchPatchBuilder47<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder47 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_stateful_set() -> PatchPatchBuilder48<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder48 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_stateful_set_scale() -> PatchPatchBuilder49<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder49 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1beta1_namespaced_stateful_set_status() -> PatchPatchBuilder50<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder50 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ControllerRevision
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_controller_revision() -> PatchPatchBuilder51<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder51 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified DaemonSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_daemon_set() -> PatchPatchBuilder52<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder52 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified DaemonSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_daemon_set_status() -> PatchPatchBuilder53<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder53 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Deployment
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_deployment() -> PatchPatchBuilder54<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder54 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified Deployment
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_deployment_scale() -> PatchPatchBuilder55<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder55 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Deployment
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_deployment_status() -> PatchPatchBuilder56<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder56 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ReplicaSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_replica_set() -> PatchPatchBuilder57<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder57 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified ReplicaSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_replica_set_scale() -> PatchPatchBuilder58<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder58 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified ReplicaSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_replica_set_status() -> PatchPatchBuilder59<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder59 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_stateful_set() -> PatchPatchBuilder60<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder60 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_stateful_set_scale() -> PatchPatchBuilder61<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder61 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified StatefulSet
    #[inline]
    pub fn patch_apps_v1beta2_namespaced_stateful_set_status() -> PatchPatchBuilder62<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder62 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified AuditSink
    #[inline]
    pub fn patch_auditregistration_v1alpha1_audit_sink() -> PatchPatchBuilder63<crate::codegen::generics::MissingName> {
        PatchPatchBuilder63 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified HorizontalPodAutoscaler
    #[inline]
    pub fn patch_autoscaling_v1_namespaced_horizontal_pod_autoscaler() -> PatchPatchBuilder64<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder64 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified HorizontalPodAutoscaler
    #[inline]
    pub fn patch_autoscaling_v1_namespaced_horizontal_pod_autoscaler_status() -> PatchPatchBuilder65<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder65 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified HorizontalPodAutoscaler
    #[inline]
    pub fn patch_autoscaling_v2beta1_namespaced_horizontal_pod_autoscaler() -> PatchPatchBuilder66<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder66 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified HorizontalPodAutoscaler
    #[inline]
    pub fn patch_autoscaling_v2beta1_namespaced_horizontal_pod_autoscaler_status() -> PatchPatchBuilder67<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder67 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified HorizontalPodAutoscaler
    #[inline]
    pub fn patch_autoscaling_v2beta2_namespaced_horizontal_pod_autoscaler() -> PatchPatchBuilder68<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder68 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified HorizontalPodAutoscaler
    #[inline]
    pub fn patch_autoscaling_v2beta2_namespaced_horizontal_pod_autoscaler_status() -> PatchPatchBuilder69<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder69 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Job
    #[inline]
    pub fn patch_batch_v1_namespaced_job() -> PatchPatchBuilder70<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder70 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Job
    #[inline]
    pub fn patch_batch_v1_namespaced_job_status() -> PatchPatchBuilder71<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder71 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified CronJob
    #[inline]
    pub fn patch_batch_v1beta1_namespaced_cron_job() -> PatchPatchBuilder72<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder72 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified CronJob
    #[inline]
    pub fn patch_batch_v1beta1_namespaced_cron_job_status() -> PatchPatchBuilder73<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder73 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified CronJob
    #[inline]
    pub fn patch_batch_v2alpha1_namespaced_cron_job() -> PatchPatchBuilder74<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder74 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified CronJob
    #[inline]
    pub fn patch_batch_v2alpha1_namespaced_cron_job_status() -> PatchPatchBuilder75<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder75 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified CertificateSigningRequest
    #[inline]
    pub fn patch_certificates_v1beta1_certificate_signing_request() -> PatchPatchBuilder76<crate::codegen::generics::MissingName> {
        PatchPatchBuilder76 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified CertificateSigningRequest
    #[inline]
    pub fn patch_certificates_v1beta1_certificate_signing_request_status() -> PatchPatchBuilder77<crate::codegen::generics::MissingName> {
        PatchPatchBuilder77 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified Lease
    #[inline]
    pub fn patch_coordination_v1_namespaced_lease() -> PatchPatchBuilder78<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder78 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Lease
    #[inline]
    pub fn patch_coordination_v1beta1_namespaced_lease() -> PatchPatchBuilder79<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder79 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Event
    #[inline]
    pub fn patch_events_v1beta1_namespaced_event() -> PatchPatchBuilder80<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder80 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified DaemonSet
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_daemon_set() -> PatchPatchBuilder81<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder81 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified DaemonSet
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_daemon_set_status() -> PatchPatchBuilder82<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder82 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Deployment
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_deployment() -> PatchPatchBuilder83<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder83 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified Deployment
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_deployment_scale() -> PatchPatchBuilder84<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder84 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Deployment
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_deployment_status() -> PatchPatchBuilder85<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder85 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Ingress
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_ingress() -> PatchPatchBuilder86<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder86 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Ingress
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_ingress_status() -> PatchPatchBuilder87<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder87 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified NetworkPolicy
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_network_policy() -> PatchPatchBuilder88<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder88 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ReplicaSet
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_replica_set() -> PatchPatchBuilder89<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder89 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified ReplicaSet
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_replica_set_scale() -> PatchPatchBuilder90<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder90 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified ReplicaSet
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_replica_set_status() -> PatchPatchBuilder91<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder91 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update scale of the specified ReplicationControllerDummy
    #[inline]
    pub fn patch_extensions_v1beta1_namespaced_replication_controller_dummy_scale() -> PatchPatchBuilder92<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder92 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified PodSecurityPolicy
    #[inline]
    pub fn patch_extensions_v1beta1_pod_security_policy() -> PatchPatchBuilder93<crate::codegen::generics::MissingName> {
        PatchPatchBuilder93 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified NetworkPolicy
    #[inline]
    pub fn patch_networking_v1_namespaced_network_policy() -> PatchPatchBuilder94<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder94 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Ingress
    #[inline]
    pub fn patch_networking_v1beta1_namespaced_ingress() -> PatchPatchBuilder95<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder95 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified Ingress
    #[inline]
    pub fn patch_networking_v1beta1_namespaced_ingress_status() -> PatchPatchBuilder96<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder96 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified RuntimeClass
    #[inline]
    pub fn patch_node_v1alpha1_runtime_class() -> PatchPatchBuilder97<crate::codegen::generics::MissingName> {
        PatchPatchBuilder97 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified RuntimeClass
    #[inline]
    pub fn patch_node_v1beta1_runtime_class() -> PatchPatchBuilder98<crate::codegen::generics::MissingName> {
        PatchPatchBuilder98 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified PodDisruptionBudget
    #[inline]
    pub fn patch_policy_v1beta1_namespaced_pod_disruption_budget() -> PatchPatchBuilder99<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder99 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified PodDisruptionBudget
    #[inline]
    pub fn patch_policy_v1beta1_namespaced_pod_disruption_budget_status() -> PatchPatchBuilder100<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder100 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified PodSecurityPolicy
    #[inline]
    pub fn patch_policy_v1beta1_pod_security_policy() -> PatchPatchBuilder101<crate::codegen::generics::MissingName> {
        PatchPatchBuilder101 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified ClusterRoleBinding
    #[inline]
    pub fn patch_rbac_authorization_v1_cluster_role_binding() -> PatchPatchBuilder102<crate::codegen::generics::MissingName> {
        PatchPatchBuilder102 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified ClusterRole
    #[inline]
    pub fn patch_rbac_authorization_v1_cluster_role() -> PatchPatchBuilder103<crate::codegen::generics::MissingName> {
        PatchPatchBuilder103 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified RoleBinding
    #[inline]
    pub fn patch_rbac_authorization_v1_namespaced_role_binding() -> PatchPatchBuilder104<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder104 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Role
    #[inline]
    pub fn patch_rbac_authorization_v1_namespaced_role() -> PatchPatchBuilder105<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder105 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ClusterRoleBinding
    #[inline]
    pub fn patch_rbac_authorization_v1alpha1_cluster_role_binding() -> PatchPatchBuilder106<crate::codegen::generics::MissingName> {
        PatchPatchBuilder106 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified ClusterRole
    #[inline]
    pub fn patch_rbac_authorization_v1alpha1_cluster_role() -> PatchPatchBuilder107<crate::codegen::generics::MissingName> {
        PatchPatchBuilder107 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified RoleBinding
    #[inline]
    pub fn patch_rbac_authorization_v1alpha1_namespaced_role_binding() -> PatchPatchBuilder108<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder108 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Role
    #[inline]
    pub fn patch_rbac_authorization_v1alpha1_namespaced_role() -> PatchPatchBuilder109<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder109 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified ClusterRoleBinding
    #[inline]
    pub fn patch_rbac_authorization_v1beta1_cluster_role_binding() -> PatchPatchBuilder110<crate::codegen::generics::MissingName> {
        PatchPatchBuilder110 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified ClusterRole
    #[inline]
    pub fn patch_rbac_authorization_v1beta1_cluster_role() -> PatchPatchBuilder111<crate::codegen::generics::MissingName> {
        PatchPatchBuilder111 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified RoleBinding
    #[inline]
    pub fn patch_rbac_authorization_v1beta1_namespaced_role_binding() -> PatchPatchBuilder112<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder112 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified Role
    #[inline]
    pub fn patch_rbac_authorization_v1beta1_namespaced_role() -> PatchPatchBuilder113<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder113 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified PriorityClass
    #[inline]
    pub fn patch_scheduling_v1_priority_class() -> PatchPatchBuilder114<crate::codegen::generics::MissingName> {
        PatchPatchBuilder114 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified PriorityClass
    #[inline]
    pub fn patch_scheduling_v1alpha1_priority_class() -> PatchPatchBuilder115<crate::codegen::generics::MissingName> {
        PatchPatchBuilder115 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified PriorityClass
    #[inline]
    pub fn patch_scheduling_v1beta1_priority_class() -> PatchPatchBuilder116<crate::codegen::generics::MissingName> {
        PatchPatchBuilder116 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified PodPreset
    #[inline]
    pub fn patch_settings_v1alpha1_namespaced_pod_preset() -> PatchPatchBuilder117<crate::codegen::generics::MissingName, crate::codegen::generics::MissingNamespace> {
        PatchPatchBuilder117 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
            _param_namespace: core::marker::PhantomData,
        }
    }

    /// partially update the specified StorageClass
    #[inline]
    pub fn patch_storage_v1_storage_class() -> PatchPatchBuilder118<crate::codegen::generics::MissingName> {
        PatchPatchBuilder118 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified VolumeAttachment
    #[inline]
    pub fn patch_storage_v1_volume_attachment() -> PatchPatchBuilder119<crate::codegen::generics::MissingName> {
        PatchPatchBuilder119 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update status of the specified VolumeAttachment
    #[inline]
    pub fn patch_storage_v1_volume_attachment_status() -> PatchPatchBuilder120<crate::codegen::generics::MissingName> {
        PatchPatchBuilder120 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified VolumeAttachment
    #[inline]
    pub fn patch_storage_v1alpha1_volume_attachment() -> PatchPatchBuilder121<crate::codegen::generics::MissingName> {
        PatchPatchBuilder121 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified CSIDriver
    #[inline]
    pub fn patch_storage_v1beta1_csi_driver() -> PatchPatchBuilder122<crate::codegen::generics::MissingName> {
        PatchPatchBuilder122 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified CSINode
    #[inline]
    pub fn patch_storage_v1beta1_csi_node() -> PatchPatchBuilder123<crate::codegen::generics::MissingName> {
        PatchPatchBuilder123 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified StorageClass
    #[inline]
    pub fn patch_storage_v1beta1_storage_class() -> PatchPatchBuilder124<crate::codegen::generics::MissingName> {
        PatchPatchBuilder124 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }

    /// partially update the specified VolumeAttachment
    #[inline]
    pub fn patch_storage_v1beta1_volume_attachment() -> PatchPatchBuilder125<crate::codegen::generics::MissingName> {
        PatchPatchBuilder125 {
            inner: Default::default(),
            _param_name: core::marker::PhantomData,
        }
    }
}

impl Into<Patch> for PatchPatchBuilder<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder1<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder2<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder3<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder4<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder5<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder6<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder7<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder8<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder9<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder10<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder11<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder12<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder13<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder14<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder15<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder16<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder17<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder18<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder19<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder20<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder21<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder22<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder23<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder24<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder25<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder26<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder27<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder28<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder29<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder30<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder31<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder32<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder33<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder34<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder35<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder36<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder37<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder38<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder39<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder40<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder41<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder42<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder43<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder44<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder45<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder46<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder47<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder48<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder49<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder50<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder51<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder52<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder53<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder54<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder55<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder56<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder57<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder58<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder59<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder60<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder61<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder62<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder63<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder64<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder65<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder66<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder67<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder68<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder69<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder70<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder71<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder72<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder73<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder74<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder75<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder76<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder77<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder78<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder79<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder80<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder81<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder82<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder83<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder84<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder85<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder86<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder87<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder88<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder89<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder90<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder91<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder92<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder93<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder94<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder95<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder96<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder97<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder98<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder99<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder100<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder101<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder102<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder103<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder104<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder105<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder106<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder107<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder108<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder109<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder110<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder111<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder112<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder113<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder114<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder115<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder116<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder117<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder118<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder119<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder120<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder121<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder122<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder123<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder124<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

impl Into<Patch> for PatchPatchBuilder125<crate::codegen::generics::NameExists> {
    fn into(self) -> Patch {
        self.inner.body
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_config_map`](./struct.Patch.html#method.patch_core_v1_namespaced_config_map) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder<Name, Namespace> {
    inner: PatchPatchBuilderContainer,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilderContainer {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ConfigMap
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::config_map::ConfigMap;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/configmaps/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_endpoints`](./struct.Patch.html#method.patch_core_v1_namespaced_endpoints) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder1<Name, Namespace> {
    inner: PatchPatchBuilder1Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder1Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder1<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Endpoints
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder1<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder1<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder1<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::endpoints::Endpoints;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/endpoints/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_event`](./struct.Patch.html#method.patch_core_v1_namespaced_event) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder2<Name, Namespace> {
    inner: PatchPatchBuilder2Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder2Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder2<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Event
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder2<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder2<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder2<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::event::Event;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/events/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_limit_range`](./struct.Patch.html#method.patch_core_v1_namespaced_limit_range) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder3<Name, Namespace> {
    inner: PatchPatchBuilder3Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder3Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder3<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the LimitRange
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder3<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder3<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder3<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::limit_range::LimitRange;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/limitranges/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_persistent_volume_claim`](./struct.Patch.html#method.patch_core_v1_namespaced_persistent_volume_claim) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder4<Name, Namespace> {
    inner: PatchPatchBuilder4Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder4Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder4<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PersistentVolumeClaim
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder4<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder4<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder4<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::persistent_volume_claim::PersistentVolumeClaim;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_persistent_volume_claim_status`](./struct.Patch.html#method.patch_core_v1_namespaced_persistent_volume_claim_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder5<Name, Namespace> {
    inner: PatchPatchBuilder5Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder5Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder5<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PersistentVolumeClaim
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder5<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder5<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder5<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::persistent_volume_claim::PersistentVolumeClaim;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_pod`](./struct.Patch.html#method.patch_core_v1_namespaced_pod) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder6<Name, Namespace> {
    inner: PatchPatchBuilder6Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder6Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder6<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Pod
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder6<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder6<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder6<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::pod::Pod;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/pods/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_pod_status`](./struct.Patch.html#method.patch_core_v1_namespaced_pod_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder7<Name, Namespace> {
    inner: PatchPatchBuilder7Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder7Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder7<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Pod
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder7<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder7<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder7<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::pod::Pod;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/pods/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_pod_template`](./struct.Patch.html#method.patch_core_v1_namespaced_pod_template) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder8<Name, Namespace> {
    inner: PatchPatchBuilder8Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder8Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder8<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PodTemplate
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder8<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder8<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder8<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::pod_template::PodTemplate;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/podtemplates/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_replication_controller`](./struct.Patch.html#method.patch_core_v1_namespaced_replication_controller) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder9<Name, Namespace> {
    inner: PatchPatchBuilder9Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder9Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder9<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicationController
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder9<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder9<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder9<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::replication_controller::ReplicationController;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/replicationcontrollers/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_replication_controller_scale`](./struct.Patch.html#method.patch_core_v1_namespaced_replication_controller_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder10<Name, Namespace> {
    inner: PatchPatchBuilder10Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder10Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder10<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder10<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder10<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder10<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_replication_controller_status`](./struct.Patch.html#method.patch_core_v1_namespaced_replication_controller_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder11<Name, Namespace> {
    inner: PatchPatchBuilder11Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder11Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder11<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicationController
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder11<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder11<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder11<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::replication_controller::ReplicationController;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_resource_quota`](./struct.Patch.html#method.patch_core_v1_namespaced_resource_quota) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder12<Name, Namespace> {
    inner: PatchPatchBuilder12Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder12Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder12<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ResourceQuota
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder12<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder12<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder12<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::resource_quota::ResourceQuota;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/resourcequotas/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_resource_quota_status`](./struct.Patch.html#method.patch_core_v1_namespaced_resource_quota_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder13<Name, Namespace> {
    inner: PatchPatchBuilder13Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder13Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder13<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ResourceQuota
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder13<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder13<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder13<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::resource_quota::ResourceQuota;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/resourcequotas/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_secret`](./struct.Patch.html#method.patch_core_v1_namespaced_secret) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder14<Name, Namespace> {
    inner: PatchPatchBuilder14Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder14Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder14<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Secret
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder14<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder14<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder14<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::secret::Secret;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/secrets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_service_account`](./struct.Patch.html#method.patch_core_v1_namespaced_service_account) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder15<Name, Namespace> {
    inner: PatchPatchBuilder15Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder15Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder15<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ServiceAccount
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder15<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder15<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder15<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::service_account::ServiceAccount;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/serviceaccounts/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_service`](./struct.Patch.html#method.patch_core_v1_namespaced_service) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder16<Name, Namespace> {
    inner: PatchPatchBuilder16Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder16Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder16<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Service
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder16<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder16<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder16<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::service::Service;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/services/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespaced_service_status`](./struct.Patch.html#method.patch_core_v1_namespaced_service_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder17<Name, Namespace> {
    inner: PatchPatchBuilder17Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder17Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder17<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Service
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder17<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder17<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder17<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::service::Service;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{namespace}/services/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespace`](./struct.Patch.html#method.patch_core_v1_namespace) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder18<Name> {
    inner: PatchPatchBuilder18Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder18Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder18<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Namespace
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder18<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder18<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::namespace::Namespace;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_namespace_status`](./struct.Patch.html#method.patch_core_v1_namespace_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder19<Name> {
    inner: PatchPatchBuilder19Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder19Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder19<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Namespace
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder19<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder19<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::namespace::Namespace;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/namespaces/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_node`](./struct.Patch.html#method.patch_core_v1_node) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder20<Name> {
    inner: PatchPatchBuilder20Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder20Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder20<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Node
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder20<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder20<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::node::Node;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/nodes/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_node_status`](./struct.Patch.html#method.patch_core_v1_node_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder21<Name> {
    inner: PatchPatchBuilder21Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder21Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder21<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Node
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder21<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder21<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::node::Node;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/nodes/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_persistent_volume`](./struct.Patch.html#method.patch_core_v1_persistent_volume) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder22<Name> {
    inner: PatchPatchBuilder22Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder22Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder22<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PersistentVolume
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder22<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder22<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::persistent_volume::PersistentVolume;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/persistentvolumes/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_core_v1_persistent_volume_status`](./struct.Patch.html#method.patch_core_v1_persistent_volume_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder23<Name> {
    inner: PatchPatchBuilder23Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder23Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder23<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PersistentVolume
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder23<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder23<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::core::v1::persistent_volume::PersistentVolume;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/api/v1/persistentvolumes/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_admissionregistration_v1beta1_mutating_webhook_configuration`](./struct.Patch.html#method.patch_admissionregistration_v1beta1_mutating_webhook_configuration) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder24<Name> {
    inner: PatchPatchBuilder24Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder24Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder24<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the MutatingWebhookConfiguration
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder24<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder24<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::admissionregistration::v1beta1::mutating_webhook_configuration::MutatingWebhookConfiguration;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_admissionregistration_v1beta1_validating_webhook_configuration`](./struct.Patch.html#method.patch_admissionregistration_v1beta1_validating_webhook_configuration) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder25<Name> {
    inner: PatchPatchBuilder25Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder25Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder25<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ValidatingWebhookConfiguration
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder25<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder25<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::admissionregistration::v1beta1::validating_webhook_configuration::ValidatingWebhookConfiguration;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apiextensions_v1beta1_custom_resource_definition`](./struct.Patch.html#method.patch_apiextensions_v1beta1_custom_resource_definition) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder26<Name> {
    inner: PatchPatchBuilder26Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder26Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder26<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CustomResourceDefinition
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder26<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder26<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::apiextensions_apiserver::pkg::apis::apiextensions::v1beta1::custom_resource_definition::CustomResourceDefinition<serde_json::Value>;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .header(http::header::ACCEPT.as_str(), "application/json")
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apiextensions_v1beta1_custom_resource_definition_status`](./struct.Patch.html#method.patch_apiextensions_v1beta1_custom_resource_definition_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder27<Name> {
    inner: PatchPatchBuilder27Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder27Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder27<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CustomResourceDefinition
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder27<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder27<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::apiextensions_apiserver::pkg::apis::apiextensions::v1beta1::custom_resource_definition::CustomResourceDefinition<serde_json::Value>;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .header(http::header::ACCEPT.as_str(), "application/json")
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apiregistration_v1api_service`](./struct.Patch.html#method.patch_apiregistration_v1api_service) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder28<Name> {
    inner: PatchPatchBuilder28Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder28Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder28<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the APIService
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder28<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder28<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::kube_aggregator::pkg::apis::apiregistration::v1::api_service::ApiService;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apiregistration.k8s.io/v1/apiservices/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apiregistration_v1api_service_status`](./struct.Patch.html#method.patch_apiregistration_v1api_service_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder29<Name> {
    inner: PatchPatchBuilder29Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder29Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder29<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the APIService
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder29<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder29<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::kube_aggregator::pkg::apis::apiregistration::v1::api_service::ApiService;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apiregistration.k8s.io/v1/apiservices/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apiregistration_v1beta1_api_service`](./struct.Patch.html#method.patch_apiregistration_v1beta1_api_service) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder30<Name> {
    inner: PatchPatchBuilder30Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder30Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder30<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the APIService
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder30<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder30<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::kube_aggregator::pkg::apis::apiregistration::v1beta1::api_service::ApiService;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apiregistration_v1beta1_api_service_status`](./struct.Patch.html#method.patch_apiregistration_v1beta1_api_service_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder31<Name> {
    inner: PatchPatchBuilder31Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder31Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder31<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the APIService
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder31<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder31<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::kube_aggregator::pkg::apis::apiregistration::v1beta1::api_service::ApiService;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_controller_revision`](./struct.Patch.html#method.patch_apps_v1_namespaced_controller_revision) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder32<Name, Namespace> {
    inner: PatchPatchBuilder32Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder32Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder32<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ControllerRevision
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder32<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder32<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder32<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::controller_revision::ControllerRevision;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_daemon_set`](./struct.Patch.html#method.patch_apps_v1_namespaced_daemon_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder33<Name, Namespace> {
    inner: PatchPatchBuilder33Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder33Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder33<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the DaemonSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder33<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder33<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder33<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::daemon_set::DaemonSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_daemon_set_status`](./struct.Patch.html#method.patch_apps_v1_namespaced_daemon_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder34<Name, Namespace> {
    inner: PatchPatchBuilder34Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder34Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder34<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the DaemonSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder34<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder34<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder34<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::daemon_set::DaemonSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_deployment`](./struct.Patch.html#method.patch_apps_v1_namespaced_deployment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder35<Name, Namespace> {
    inner: PatchPatchBuilder35Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder35Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder35<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder35<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder35<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder35<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/deployments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_deployment_scale`](./struct.Patch.html#method.patch_apps_v1_namespaced_deployment_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder36<Name, Namespace> {
    inner: PatchPatchBuilder36Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder36Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder36<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder36<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder36<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder36<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_deployment_status`](./struct.Patch.html#method.patch_apps_v1_namespaced_deployment_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder37<Name, Namespace> {
    inner: PatchPatchBuilder37Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder37Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder37<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder37<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder37<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder37<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_replica_set`](./struct.Patch.html#method.patch_apps_v1_namespaced_replica_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder38<Name, Namespace> {
    inner: PatchPatchBuilder38Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder38Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder38<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicaSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder38<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder38<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder38<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::replica_set::ReplicaSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/replicasets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_replica_set_scale`](./struct.Patch.html#method.patch_apps_v1_namespaced_replica_set_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder39<Name, Namespace> {
    inner: PatchPatchBuilder39Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder39Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder39<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder39<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder39<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder39<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_replica_set_status`](./struct.Patch.html#method.patch_apps_v1_namespaced_replica_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder40<Name, Namespace> {
    inner: PatchPatchBuilder40Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder40Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder40<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicaSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder40<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder40<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder40<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::replica_set::ReplicaSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_stateful_set`](./struct.Patch.html#method.patch_apps_v1_namespaced_stateful_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder41<Name, Namespace> {
    inner: PatchPatchBuilder41Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder41Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder41<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StatefulSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder41<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder41<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder41<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::stateful_set::StatefulSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_stateful_set_scale`](./struct.Patch.html#method.patch_apps_v1_namespaced_stateful_set_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder42<Name, Namespace> {
    inner: PatchPatchBuilder42Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder42Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder42<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder42<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder42<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder42<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1_namespaced_stateful_set_status`](./struct.Patch.html#method.patch_apps_v1_namespaced_stateful_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder43<Name, Namespace> {
    inner: PatchPatchBuilder43Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder43Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder43<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StatefulSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder43<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder43<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder43<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1::stateful_set::StatefulSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_controller_revision`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_controller_revision) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder44<Name, Namespace> {
    inner: PatchPatchBuilder44Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder44Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder44<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ControllerRevision
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder44<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder44<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder44<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::controller_revision::ControllerRevision;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_deployment`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_deployment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder45<Name, Namespace> {
    inner: PatchPatchBuilder45Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder45Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder45<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder45<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder45<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder45<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_deployment_scale`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_deployment_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder46<Name, Namespace> {
    inner: PatchPatchBuilder46Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder46Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder46<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder46<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder46<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder46<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_deployment_status`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_deployment_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder47<Name, Namespace> {
    inner: PatchPatchBuilder47Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder47Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder47<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder47<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder47<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder47<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_stateful_set`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_stateful_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder48<Name, Namespace> {
    inner: PatchPatchBuilder48Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder48Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder48<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StatefulSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder48<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder48<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder48<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::stateful_set::StatefulSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_stateful_set_scale`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_stateful_set_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder49<Name, Namespace> {
    inner: PatchPatchBuilder49Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder49Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder49<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder49<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder49<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder49<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta1_namespaced_stateful_set_status`](./struct.Patch.html#method.patch_apps_v1beta1_namespaced_stateful_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder50<Name, Namespace> {
    inner: PatchPatchBuilder50Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder50Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder50<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StatefulSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder50<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder50<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder50<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta1::stateful_set::StatefulSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_controller_revision`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_controller_revision) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder51<Name, Namespace> {
    inner: PatchPatchBuilder51Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder51Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder51<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ControllerRevision
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder51<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder51<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder51<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::controller_revision::ControllerRevision;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_daemon_set`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_daemon_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder52<Name, Namespace> {
    inner: PatchPatchBuilder52Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder52Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder52<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the DaemonSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder52<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder52<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder52<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::daemon_set::DaemonSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_daemon_set_status`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_daemon_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder53<Name, Namespace> {
    inner: PatchPatchBuilder53Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder53Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder53<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the DaemonSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder53<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder53<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder53<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::daemon_set::DaemonSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_deployment`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_deployment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder54<Name, Namespace> {
    inner: PatchPatchBuilder54Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder54Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder54<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder54<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder54<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder54<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_deployment_scale`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_deployment_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder55<Name, Namespace> {
    inner: PatchPatchBuilder55Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder55Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder55<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder55<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder55<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder55<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_deployment_status`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_deployment_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder56<Name, Namespace> {
    inner: PatchPatchBuilder56Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder56Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder56<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder56<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder56<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder56<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_replica_set`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_replica_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder57<Name, Namespace> {
    inner: PatchPatchBuilder57Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder57Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder57<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicaSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder57<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder57<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder57<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::replica_set::ReplicaSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_replica_set_scale`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_replica_set_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder58<Name, Namespace> {
    inner: PatchPatchBuilder58Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder58Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder58<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder58<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder58<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder58<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_replica_set_status`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_replica_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder59<Name, Namespace> {
    inner: PatchPatchBuilder59Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder59Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder59<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicaSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder59<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder59<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder59<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::replica_set::ReplicaSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_stateful_set`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_stateful_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder60<Name, Namespace> {
    inner: PatchPatchBuilder60Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder60Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder60<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StatefulSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder60<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder60<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder60<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::stateful_set::StatefulSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_stateful_set_scale`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_stateful_set_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder61<Name, Namespace> {
    inner: PatchPatchBuilder61Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder61Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder61<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder61<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder61<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder61<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_apps_v1beta2_namespaced_stateful_set_status`](./struct.Patch.html#method.patch_apps_v1beta2_namespaced_stateful_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder62<Name, Namespace> {
    inner: PatchPatchBuilder62Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder62Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder62<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StatefulSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder62<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder62<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder62<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::apps::v1beta2::stateful_set::StatefulSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_auditregistration_v1alpha1_audit_sink`](./struct.Patch.html#method.patch_auditregistration_v1alpha1_audit_sink) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder63<Name> {
    inner: PatchPatchBuilder63Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder63Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder63<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the AuditSink
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder63<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder63<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::auditregistration::v1alpha1::audit_sink::AuditSink;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/auditregistration.k8s.io/v1alpha1/auditsinks/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_autoscaling_v1_namespaced_horizontal_pod_autoscaler`](./struct.Patch.html#method.patch_autoscaling_v1_namespaced_horizontal_pod_autoscaler) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder64<Name, Namespace> {
    inner: PatchPatchBuilder64Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder64Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder64<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the HorizontalPodAutoscaler
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder64<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder64<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder64<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v1::horizontal_pod_autoscaler::HorizontalPodAutoscaler;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_autoscaling_v1_namespaced_horizontal_pod_autoscaler_status`](./struct.Patch.html#method.patch_autoscaling_v1_namespaced_horizontal_pod_autoscaler_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder65<Name, Namespace> {
    inner: PatchPatchBuilder65Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder65Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder65<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the HorizontalPodAutoscaler
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder65<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder65<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder65<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v1::horizontal_pod_autoscaler::HorizontalPodAutoscaler;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_autoscaling_v2beta1_namespaced_horizontal_pod_autoscaler`](./struct.Patch.html#method.patch_autoscaling_v2beta1_namespaced_horizontal_pod_autoscaler) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder66<Name, Namespace> {
    inner: PatchPatchBuilder66Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder66Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder66<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the HorizontalPodAutoscaler
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder66<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder66<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder66<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v2beta1::horizontal_pod_autoscaler::HorizontalPodAutoscaler;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_autoscaling_v2beta1_namespaced_horizontal_pod_autoscaler_status`](./struct.Patch.html#method.patch_autoscaling_v2beta1_namespaced_horizontal_pod_autoscaler_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder67<Name, Namespace> {
    inner: PatchPatchBuilder67Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder67Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder67<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the HorizontalPodAutoscaler
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder67<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder67<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder67<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v2beta1::horizontal_pod_autoscaler::HorizontalPodAutoscaler;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_autoscaling_v2beta2_namespaced_horizontal_pod_autoscaler`](./struct.Patch.html#method.patch_autoscaling_v2beta2_namespaced_horizontal_pod_autoscaler) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder68<Name, Namespace> {
    inner: PatchPatchBuilder68Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder68Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder68<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the HorizontalPodAutoscaler
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder68<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder68<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder68<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v2beta2::horizontal_pod_autoscaler::HorizontalPodAutoscaler;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_autoscaling_v2beta2_namespaced_horizontal_pod_autoscaler_status`](./struct.Patch.html#method.patch_autoscaling_v2beta2_namespaced_horizontal_pod_autoscaler_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder69<Name, Namespace> {
    inner: PatchPatchBuilder69Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder69Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder69<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the HorizontalPodAutoscaler
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder69<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder69<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder69<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::autoscaling::v2beta2::horizontal_pod_autoscaler::HorizontalPodAutoscaler;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_batch_v1_namespaced_job`](./struct.Patch.html#method.patch_batch_v1_namespaced_job) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder70<Name, Namespace> {
    inner: PatchPatchBuilder70Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder70Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder70<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Job
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder70<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder70<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder70<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::batch::v1::job::Job;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/batch/v1/namespaces/{namespace}/jobs/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_batch_v1_namespaced_job_status`](./struct.Patch.html#method.patch_batch_v1_namespaced_job_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder71<Name, Namespace> {
    inner: PatchPatchBuilder71Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder71Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder71<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Job
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder71<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder71<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder71<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::batch::v1::job::Job;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_batch_v1beta1_namespaced_cron_job`](./struct.Patch.html#method.patch_batch_v1beta1_namespaced_cron_job) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder72<Name, Namespace> {
    inner: PatchPatchBuilder72Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder72Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder72<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CronJob
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder72<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder72<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder72<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::batch::v1beta1::cron_job::CronJob;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_batch_v1beta1_namespaced_cron_job_status`](./struct.Patch.html#method.patch_batch_v1beta1_namespaced_cron_job_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder73<Name, Namespace> {
    inner: PatchPatchBuilder73Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder73Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder73<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CronJob
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder73<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder73<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder73<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::batch::v1beta1::cron_job::CronJob;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_batch_v2alpha1_namespaced_cron_job`](./struct.Patch.html#method.patch_batch_v2alpha1_namespaced_cron_job) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder74<Name, Namespace> {
    inner: PatchPatchBuilder74Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder74Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder74<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CronJob
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder74<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder74<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder74<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::batch::v2alpha1::cron_job::CronJob;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_batch_v2alpha1_namespaced_cron_job_status`](./struct.Patch.html#method.patch_batch_v2alpha1_namespaced_cron_job_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder75<Name, Namespace> {
    inner: PatchPatchBuilder75Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder75Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder75<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CronJob
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder75<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder75<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder75<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::batch::v2alpha1::cron_job::CronJob;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_certificates_v1beta1_certificate_signing_request`](./struct.Patch.html#method.patch_certificates_v1beta1_certificate_signing_request) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder76<Name> {
    inner: PatchPatchBuilder76Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder76Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder76<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CertificateSigningRequest
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder76<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder76<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::certificates::v1beta1::certificate_signing_request::CertificateSigningRequest;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_certificates_v1beta1_certificate_signing_request_status`](./struct.Patch.html#method.patch_certificates_v1beta1_certificate_signing_request_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder77<Name> {
    inner: PatchPatchBuilder77Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder77Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder77<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CertificateSigningRequest
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder77<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder77<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::certificates::v1beta1::certificate_signing_request::CertificateSigningRequest;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_coordination_v1_namespaced_lease`](./struct.Patch.html#method.patch_coordination_v1_namespaced_lease) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder78<Name, Namespace> {
    inner: PatchPatchBuilder78Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder78Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder78<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Lease
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder78<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder78<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder78<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::coordination::v1::lease::Lease;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_coordination_v1beta1_namespaced_lease`](./struct.Patch.html#method.patch_coordination_v1beta1_namespaced_lease) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder79<Name, Namespace> {
    inner: PatchPatchBuilder79Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder79Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder79<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Lease
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder79<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder79<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder79<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::coordination::v1beta1::lease::Lease;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_events_v1beta1_namespaced_event`](./struct.Patch.html#method.patch_events_v1beta1_namespaced_event) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder80<Name, Namespace> {
    inner: PatchPatchBuilder80Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder80Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder80<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Event
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder80<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder80<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder80<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::events::v1beta1::event::Event;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_daemon_set`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_daemon_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder81<Name, Namespace> {
    inner: PatchPatchBuilder81Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder81Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder81<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the DaemonSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder81<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder81<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder81<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::daemon_set::DaemonSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_daemon_set_status`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_daemon_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder82<Name, Namespace> {
    inner: PatchPatchBuilder82Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder82Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder82<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the DaemonSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder82<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder82<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder82<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::daemon_set::DaemonSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_deployment`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_deployment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder83<Name, Namespace> {
    inner: PatchPatchBuilder83Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder83Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder83<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder83<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder83<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder83<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_deployment_scale`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_deployment_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder84<Name, Namespace> {
    inner: PatchPatchBuilder84Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder84Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder84<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder84<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder84<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder84<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_deployment_status`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_deployment_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder85<Name, Namespace> {
    inner: PatchPatchBuilder85Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder85Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder85<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Deployment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder85<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder85<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder85<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::deployment::Deployment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_ingress`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_ingress) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder86<Name, Namespace> {
    inner: PatchPatchBuilder86Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder86Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder86<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Ingress
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder86<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder86<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder86<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::ingress::Ingress;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_ingress_status`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_ingress_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder87<Name, Namespace> {
    inner: PatchPatchBuilder87Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder87Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder87<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Ingress
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder87<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder87<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder87<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::ingress::Ingress;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_network_policy`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_network_policy) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder88<Name, Namespace> {
    inner: PatchPatchBuilder88Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder88Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder88<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the NetworkPolicy
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder88<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder88<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder88<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::network_policy::NetworkPolicy;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_replica_set`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_replica_set) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder89<Name, Namespace> {
    inner: PatchPatchBuilder89Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder89Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder89<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicaSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder89<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder89<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder89<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::replica_set::ReplicaSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_replica_set_scale`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_replica_set_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder90<Name, Namespace> {
    inner: PatchPatchBuilder90Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder90Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder90<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder90<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder90<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder90<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_replica_set_status`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_replica_set_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder91<Name, Namespace> {
    inner: PatchPatchBuilder91Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder91Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder91<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ReplicaSet
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder91<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder91<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder91<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::replica_set::ReplicaSet;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_namespaced_replication_controller_dummy_scale`](./struct.Patch.html#method.patch_extensions_v1beta1_namespaced_replication_controller_dummy_scale) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder92<Name, Namespace> {
    inner: PatchPatchBuilder92Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder92Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder92<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Scale
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder92<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder92<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder92<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::scale::Scale;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_extensions_v1beta1_pod_security_policy`](./struct.Patch.html#method.patch_extensions_v1beta1_pod_security_policy) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder93<Name> {
    inner: PatchPatchBuilder93Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder93Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder93<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PodSecurityPolicy
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder93<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder93<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::extensions::v1beta1::pod_security_policy::PodSecurityPolicy;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/extensions/v1beta1/podsecuritypolicies/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_networking_v1_namespaced_network_policy`](./struct.Patch.html#method.patch_networking_v1_namespaced_network_policy) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder94<Name, Namespace> {
    inner: PatchPatchBuilder94Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder94Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder94<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the NetworkPolicy
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder94<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder94<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder94<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::networking::v1::network_policy::NetworkPolicy;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_networking_v1beta1_namespaced_ingress`](./struct.Patch.html#method.patch_networking_v1beta1_namespaced_ingress) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder95<Name, Namespace> {
    inner: PatchPatchBuilder95Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder95Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder95<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Ingress
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder95<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder95<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder95<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::networking::v1beta1::ingress::Ingress;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_networking_v1beta1_namespaced_ingress_status`](./struct.Patch.html#method.patch_networking_v1beta1_namespaced_ingress_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder96<Name, Namespace> {
    inner: PatchPatchBuilder96Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder96Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder96<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Ingress
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder96<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder96<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder96<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::networking::v1beta1::ingress::Ingress;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_node_v1alpha1_runtime_class`](./struct.Patch.html#method.patch_node_v1alpha1_runtime_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder97<Name> {
    inner: PatchPatchBuilder97Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder97Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder97<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the RuntimeClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder97<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder97<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::node::v1alpha1::runtime_class::RuntimeClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_node_v1beta1_runtime_class`](./struct.Patch.html#method.patch_node_v1beta1_runtime_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder98<Name> {
    inner: PatchPatchBuilder98Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder98Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder98<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the RuntimeClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder98<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder98<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::node::v1beta1::runtime_class::RuntimeClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/node.k8s.io/v1beta1/runtimeclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_policy_v1beta1_namespaced_pod_disruption_budget`](./struct.Patch.html#method.patch_policy_v1beta1_namespaced_pod_disruption_budget) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder99<Name, Namespace> {
    inner: PatchPatchBuilder99Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder99Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder99<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PodDisruptionBudget
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder99<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder99<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder99<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::policy::v1beta1::pod_disruption_budget::PodDisruptionBudget;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_policy_v1beta1_namespaced_pod_disruption_budget_status`](./struct.Patch.html#method.patch_policy_v1beta1_namespaced_pod_disruption_budget_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder100<Name, Namespace> {
    inner: PatchPatchBuilder100Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder100Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder100<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PodDisruptionBudget
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder100<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder100<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder100<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::policy::v1beta1::pod_disruption_budget::PodDisruptionBudget;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_policy_v1beta1_pod_security_policy`](./struct.Patch.html#method.patch_policy_v1beta1_pod_security_policy) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder101<Name> {
    inner: PatchPatchBuilder101Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder101Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder101<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PodSecurityPolicy
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder101<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder101<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::policy::v1beta1::pod_security_policy::PodSecurityPolicy;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/policy/v1beta1/podsecuritypolicies/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1_cluster_role_binding`](./struct.Patch.html#method.patch_rbac_authorization_v1_cluster_role_binding) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder102<Name> {
    inner: PatchPatchBuilder102Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder102Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder102<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ClusterRoleBinding
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder102<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder102<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1::cluster_role_binding::ClusterRoleBinding;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1_cluster_role`](./struct.Patch.html#method.patch_rbac_authorization_v1_cluster_role) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder103<Name> {
    inner: PatchPatchBuilder103Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder103Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder103<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ClusterRole
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder103<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder103<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1::cluster_role::ClusterRole;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1_namespaced_role_binding`](./struct.Patch.html#method.patch_rbac_authorization_v1_namespaced_role_binding) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder104<Name, Namespace> {
    inner: PatchPatchBuilder104Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder104Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder104<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the RoleBinding
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder104<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder104<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder104<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1::role_binding::RoleBinding;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1_namespaced_role`](./struct.Patch.html#method.patch_rbac_authorization_v1_namespaced_role) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder105<Name, Namespace> {
    inner: PatchPatchBuilder105Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder105Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder105<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Role
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder105<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder105<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder105<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1::role::Role;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1alpha1_cluster_role_binding`](./struct.Patch.html#method.patch_rbac_authorization_v1alpha1_cluster_role_binding) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder106<Name> {
    inner: PatchPatchBuilder106Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder106Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder106<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ClusterRoleBinding
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder106<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder106<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1alpha1::cluster_role_binding::ClusterRoleBinding;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1alpha1_cluster_role`](./struct.Patch.html#method.patch_rbac_authorization_v1alpha1_cluster_role) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder107<Name> {
    inner: PatchPatchBuilder107Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder107Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder107<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ClusterRole
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder107<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder107<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1alpha1::cluster_role::ClusterRole;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1alpha1_namespaced_role_binding`](./struct.Patch.html#method.patch_rbac_authorization_v1alpha1_namespaced_role_binding) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder108<Name, Namespace> {
    inner: PatchPatchBuilder108Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder108Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder108<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the RoleBinding
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder108<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder108<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder108<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1alpha1::role_binding::RoleBinding;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1alpha1_namespaced_role`](./struct.Patch.html#method.patch_rbac_authorization_v1alpha1_namespaced_role) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder109<Name, Namespace> {
    inner: PatchPatchBuilder109Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder109Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder109<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Role
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder109<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder109<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder109<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1alpha1::role::Role;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1beta1_cluster_role_binding`](./struct.Patch.html#method.patch_rbac_authorization_v1beta1_cluster_role_binding) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder110<Name> {
    inner: PatchPatchBuilder110Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder110Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder110<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ClusterRoleBinding
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder110<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder110<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1beta1::cluster_role_binding::ClusterRoleBinding;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1beta1_cluster_role`](./struct.Patch.html#method.patch_rbac_authorization_v1beta1_cluster_role) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder111<Name> {
    inner: PatchPatchBuilder111Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder111Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder111<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the ClusterRole
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder111<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder111<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1beta1::cluster_role::ClusterRole;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1beta1_namespaced_role_binding`](./struct.Patch.html#method.patch_rbac_authorization_v1beta1_namespaced_role_binding) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder112<Name, Namespace> {
    inner: PatchPatchBuilder112Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder112Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder112<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the RoleBinding
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder112<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder112<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder112<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1beta1::role_binding::RoleBinding;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_rbac_authorization_v1beta1_namespaced_role`](./struct.Patch.html#method.patch_rbac_authorization_v1beta1_namespaced_role) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder113<Name, Namespace> {
    inner: PatchPatchBuilder113Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder113Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder113<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the Role
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder113<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder113<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder113<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::rbac::v1beta1::role::Role;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_scheduling_v1_priority_class`](./struct.Patch.html#method.patch_scheduling_v1_priority_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder114<Name> {
    inner: PatchPatchBuilder114Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder114Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder114<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PriorityClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder114<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder114<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::scheduling::v1::priority_class::PriorityClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/scheduling.k8s.io/v1/priorityclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_scheduling_v1alpha1_priority_class`](./struct.Patch.html#method.patch_scheduling_v1alpha1_priority_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder115<Name> {
    inner: PatchPatchBuilder115Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder115Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder115<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PriorityClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder115<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder115<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::scheduling::v1alpha1::priority_class::PriorityClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_scheduling_v1beta1_priority_class`](./struct.Patch.html#method.patch_scheduling_v1beta1_priority_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder116<Name> {
    inner: PatchPatchBuilder116Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder116Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder116<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PriorityClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder116<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder116<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::scheduling::v1beta1::priority_class::PriorityClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_settings_v1alpha1_namespaced_pod_preset`](./struct.Patch.html#method.patch_settings_v1alpha1_namespaced_pod_preset) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder117<Name, Namespace> {
    inner: PatchPatchBuilder117Container,
    _param_name: core::marker::PhantomData<Name>,
    _param_namespace: core::marker::PhantomData<Namespace>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder117Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_namespace: Option<String>,
    param_pretty: Option<String>,
}

impl<Name, Namespace> PatchPatchBuilder117<Name, Namespace> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the PodPreset
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder117<crate::codegen::generics::NameExists, Namespace> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// object name and auth scope, such as for teams and projects
    #[inline]
    pub fn namespace(mut self, value: impl Into<String>) -> PatchPatchBuilder117<Name, crate::codegen::generics::NamespaceExists> {
        self.inner.param_namespace = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder117<crate::codegen::generics::NameExists, crate::codegen::generics::NamespaceExists> {
    type Output = crate::codegen::io::k8s::api::settings::v1alpha1::pod_preset::PodPreset;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?"), namespace=self.inner.param_namespace.as_ref().expect("missing parameter namespace?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1_storage_class`](./struct.Patch.html#method.patch_storage_v1_storage_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder118<Name> {
    inner: PatchPatchBuilder118Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder118Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder118<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StorageClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder118<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder118<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1::storage_class::StorageClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1/storageclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1_volume_attachment`](./struct.Patch.html#method.patch_storage_v1_volume_attachment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder119<Name> {
    inner: PatchPatchBuilder119Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder119Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder119<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the VolumeAttachment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder119<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder119<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1::volume_attachment::VolumeAttachment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1/volumeattachments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1_volume_attachment_status`](./struct.Patch.html#method.patch_storage_v1_volume_attachment_status) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder120<Name> {
    inner: PatchPatchBuilder120Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder120Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder120<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the VolumeAttachment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder120<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder120<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1::volume_attachment::VolumeAttachment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1/volumeattachments/{name}/status", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1alpha1_volume_attachment`](./struct.Patch.html#method.patch_storage_v1alpha1_volume_attachment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder121<Name> {
    inner: PatchPatchBuilder121Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder121Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder121<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the VolumeAttachment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder121<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder121<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1alpha1::volume_attachment::VolumeAttachment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1beta1_csi_driver`](./struct.Patch.html#method.patch_storage_v1beta1_csi_driver) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder122<Name> {
    inner: PatchPatchBuilder122Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder122Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder122<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CSIDriver
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder122<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder122<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1beta1::csi_driver::CsiDriver;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1beta1/csidrivers/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1beta1_csi_node`](./struct.Patch.html#method.patch_storage_v1beta1_csi_node) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder123<Name> {
    inner: PatchPatchBuilder123Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder123Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder123<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the CSINode
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder123<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder123<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1beta1::csi_node::CsiNode;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1beta1/csinodes/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1beta1_storage_class`](./struct.Patch.html#method.patch_storage_v1beta1_storage_class) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder124<Name> {
    inner: PatchPatchBuilder124Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder124Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder124<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the StorageClass
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder124<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder124<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1beta1::storage_class::StorageClass;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1beta1/storageclasses/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

/// Builder created by [`Patch::patch_storage_v1beta1_volume_attachment`](./struct.Patch.html#method.patch_storage_v1beta1_volume_attachment) method for a `PATCH` operation associated with `Patch`.
#[repr(transparent)]
#[derive(Debug, Clone)]
pub struct PatchPatchBuilder125<Name> {
    inner: PatchPatchBuilder125Container,
    _param_name: core::marker::PhantomData<Name>,
}

#[derive(Debug, Default, Clone)]
struct PatchPatchBuilder125Container {
    body: self::Patch,
    param_dry_run: Option<String>,
    param_field_manager: Option<String>,
    param_force: Option<bool>,
    param_name: Option<String>,
    param_pretty: Option<String>,
}

impl<Name> PatchPatchBuilder125<Name> {
    /// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    #[inline]
    pub fn dry_run(mut self, value: impl Into<String>) -> Self {
        self.inner.param_dry_run = Some(value.into());
        self
    }

    /// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
    #[inline]
    pub fn field_manager(mut self, value: impl Into<String>) -> Self {
        self.inner.param_field_manager = Some(value.into());
        self
    }

    /// Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
    #[inline]
    pub fn force(mut self, value: impl Into<bool>) -> Self {
        self.inner.param_force = Some(value.into());
        self
    }

    /// name of the VolumeAttachment
    #[inline]
    pub fn name(mut self, value: impl Into<String>) -> PatchPatchBuilder125<crate::codegen::generics::NameExists> {
        self.inner.param_name = Some(value.into());
        unsafe { std::mem::transmute(self) }
    }

    /// If 'true', then the output is pretty printed.
    #[inline]
    pub fn pretty(mut self, value: impl Into<String>) -> Self {
        self.inner.param_pretty = Some(value.into());
        self
    }
}

impl<Client: crate::codegen::client::ApiClient + Sync + 'static> crate::codegen::client::Sendable<Client> for PatchPatchBuilder125<crate::codegen::generics::NameExists> {
    type Output = crate::codegen::io::k8s::api::storage::v1beta1::volume_attachment::VolumeAttachment;

    const METHOD: http::Method = http::Method::PATCH;

    fn rel_path(&self) -> std::borrow::Cow<'static, str> {
        format!("/apis/storage.k8s.io/v1beta1/volumeattachments/{name}", name=self.inner.param_name.as_ref().expect("missing parameter name?")).into()
    }

    fn modify(&self, req: Client::Request) -> Result<Client::Request, crate::codegen::client::ApiError<Client::Response>> {
        use crate::codegen::client::Request;
        Ok(req
        .json(&self.inner.body)
        .query(&[
            ("dryRun", self.inner.param_dry_run.as_ref().map(std::string::ToString::to_string)),
            ("fieldManager", self.inner.param_field_manager.as_ref().map(std::string::ToString::to_string)),
            ("force", self.inner.param_force.as_ref().map(std::string::ToString::to_string)),
            ("pretty", self.inner.param_pretty.as_ref().map(std::string::ToString::to_string))
        ]))
    }
}

